Pentru inceput mi-am initializat toate variabilele de care aveam nevoie si pentru inceput mi am facut un if pentru fiecare task sef, adica cluster. Pentru inceput in fiecare cluster deschid fisierul respectiv lor, citesc numarul de legaturi pe care le care in number_leg0. Exista o variabila identica pentru fiecare cluster: number_leg1 si number_leg2. Dupa ce am citit numarul de legaturi cu un for citesc fiecare worker subordonat clusterului si il salvez intr-un vector v0, desigur exista un vector identic pentru task1 v1  si task2 v2. Dupa ce aflu workeri in for le trimit un mesaj pentru a ii informa cine este masterul lor. 
In worker dupa ce aflu cine este masterul, il salvez intr-o variabila si dupa trimit mesaj inapoi de confirmare. 
Dupa ce am facut initierea cluster-worker, putem stabili topologiile. Astfel clusterii trimit numarul lor de legaturi la ceilalti 2 clusteri si desigr ca si ei primesc numarul, ca in oglinda. Dupa ce primesc numarul de legaturi aloca vectori in care o sa primeasca si listele cu workerii. Dupa ce toate clusterele au aflat topologia si au afisat-o, este si timpul workerilor sa stie topologia. Astfel dupa ce clusterele afiseaza topologiile, acestia tirmit topologiile si la workeri, adica numarul de legaturi pt cei trei clusteri si lista de workeri. Dupa ce am terminat cerinta 1 o sa ne ocupam de cerinta 2 in care aloc vectorul v in taskul 0 si incerc sa impart in mod cat mai egal dupa cum urmeaza:
- in cazul in care am N care este mai mare decat workeri impart numarul de elemente N la workeri si inmultesc cu numarul de legaturi pentru ca sa zicem ca avem N = 10 si 6 workeri, o sa vina 1 element din vector per worker deci daca task-ul 0 are 2 elemente o sa aiba 10/6 inmultit cu 2. Dupa aceasta imparteala corecta trebuie sa ne ocum si de rest astfel: memorez restul intr-o variabila rest si verific daca restul este mai mare decat numarul de leg al primului task task 0, daca da atunci inseamna ca pot sa mai bag cate un element per worker in acel task. Daca restul este egal cu numarul de legaturi sau chiar mai mic, inseamna ca mai adaug cat mai am si fac restul 0. Aceasi verificare o fac pentru fiecare task pentru ca cum se vede si din cod ferific cu fiecare numar de legaturi.
-in cazul in care N este mai mic inseamna ca am doar rest si atunci impart exact ca mai sus dar direct abordez situatia cu rest. 
DUpa ce am facut impartirea cat mai exhilibrata, am incercat sa trimit intr-un mod cat mai eficient vectorii trimitand mai intai numarul de elemente pe care l-am calculat mai sus si dupa am trimis direct din v unde am setat adresa de inceput v+numarul de elemente al primul task si dimensiunea am pus-o numarul de elemente al taskului 1 ca sa tirmita direct din v.
Dupa ce am tirmis din 0 celeleltate au facut receve si acum ne putem ocupa sa trimitem la workeri.
Modul in care am trimis la workeri a fost in modul urmator:
-sa zicem ca pt task-ul 0 se alocau 3 termeni el avand 2 workeri. M-am gandit da facem un for pentru fiecare worker si in caz ca este ultimul worker sa ia 3 imaprit la 2 si restul cat mai ramane astfel ca primul worker sa ia 1 element si al doilea 2. Cu variabila indice mi-am salvat cate elemente am trimis pentru a stii urmatoarea adresa de la care sa trimit in continuare.
Exact acelasi lucru fac si task-urile 1 si 2 numai ca acestea impart din vectorul in care au primit partea lor din v, din vo_recv1 si v0_recv2. Dupa ce au impartit valorile workerii le primec, inmultesc cu 2 si le ptrimit inapoi unde taskurile fac exact opusul ca la SEND. Adica asa cum am trimis bucatale acum primesc bucatelele exact in aceleasi locuri. Task-ul 1 si 2 trebuie sa trimita vectorul lor la task-ul 0 unde el face exact ce a facut cand a trimis bucatelele din v, le primeste exact in aceleasi locuri. In final task 0 afiseaza rezultatul.
----BONUS 
Pentru bonus am folosit exact aceasi gandire numai ca comunicarea 0-1 nu se mai facea direct se facea prin intermediul lui 2 care 2 colecta informatia si o trimitea mai departe. In schimb se folosesc exact aceleasi variabile.
